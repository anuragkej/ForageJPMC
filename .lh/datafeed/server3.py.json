{
    "sourceFile": "datafeed/server3.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1718372001412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1718372001412,
            "name": "Commit-0",
            "content": "################################################################################\n#\n#  Permission is hereby granted, free of charge, to any person obtaining a\n#  copy of this software and associated documentation files (the \"Software\"),\n#  to deal in the Software without restriction, including without limitation\n#  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n#  and/or sell copies of the Software, and to permit persons to whom the\n#  Software is furnished to do so, subject to the following conditions:\n#\n#  The above copyright notice and this permission notice shall be included in\n#  all copies or substantial portions of the Software.\n#\n#  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n#  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n#  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n#  DEALINGS IN THE SOFTWARE.\n\n# from itertools import izip\nfrom random import normalvariate, random\nfrom datetime import timedelta, datetime\n\nimport csv\nimport dateutil.parser\nimport os.path\n\nimport operator\nimport json\nimport re\nimport threading\n\n# from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer\nimport http.server\nfrom socketserver import ThreadingMixIn\n\n################################################################################\n#\n# Config\n\n# Sim params\n\nREALTIME = True\nSIM_LENGTH = timedelta(days=365 * 5)\nMARKET_OPEN = datetime.today().replace(hour=0, minute=30, second=0)\n\n# Market parms\n#       min  / max  / std\nSPD = (2.0, 6.0, 0.1)\nPX = (60.0, 150.0, 1)\nFREQ = (12, 36, 50)\n\n# Trades\n\nOVERLAP = 4\n\n\n################################################################################\n#\n# Test Data\n\n\ndef bwalk(min, max, std):\n    \"\"\"Generates a bounded random walk.\"\"\"\n    rng = max - min\n    while True:\n        max += normalvariate(0, std)\n        yield abs((max % (rng * 2)) - rng) + min\n\n\ndef market(t0=MARKET_OPEN):\n    \"\"\"Generates a random series of market conditions,\n    (time, price, spread).\n    \"\"\"\n    for hours, px, spd in zip(bwalk(*FREQ), bwalk(*PX), bwalk(*SPD)):\n        yield t0, px, spd\n        t0 += timedelta(hours=abs(hours))\n\n\ndef orders(hist):\n    \"\"\"Generates a random set of limit orders (time, side, price, size) from\n    a series of market conditions.\n    \"\"\"\n    for t, px, spd in hist:\n        stock = \"ABC\" if random() > 0.5 else \"DEF\"\n        side, d = (\"sell\", 2) if random() > 0.5 else (\"buy\", -2)\n        order = round(normalvariate(px + (spd / d), spd / OVERLAP), 2)\n        size = int(abs(normalvariate(0, 100)))\n        yield t, stock, side, order, size\n\n\n################################################################################\n#\n# Order Book\n\n\ndef add_book(book, order, size, _age=10):\n    \"\"\"Add a new order and size to a book, and age the rest of the book.\"\"\"\n    yield order, size, _age\n    for o, s, age in book:\n        if age > 0:\n            yield o, s, age - 1\n\n\ndef clear_order(order, size, book, op=operator.ge, _notional=0):\n    \"\"\"Try to clear a sized order against a book, returning a tuple of\n    (notional, new_book) if successful, and None if not.  _notional is a\n    recursive accumulator and should not be provided by the caller.\n    \"\"\"\n    (top_order, top_size, age), tail = book[0], book[1:]\n    if op(order, top_order):\n        _notional += min(size, top_size) * top_order\n        sdiff = top_size - size\n        if sdiff > 0:\n            return _notional, list(add_book(tail, top_order, sdiff, age))\n        elif len(tail) > 0:\n            return clear_order(order, -sdiff, tail, op, _notional)\n\n\ndef clear_book(buy=None, sell=None):\n    \"\"\"Clears all crossed orders from a buy and sell book, returning the new\n    books uncrossed.\n    \"\"\"\n    while buy and sell:\n        order, size, _ = buy[0]\n        new_book = clear_order(order, size, sell)\n        if new_book:\n            sell = new_book[1]\n            buy = buy[1:]\n        else:\n            break\n    return buy, sell\n\n\ndef order_book(orders, book, stock_name):\n    \"\"\"Generates a series of order books from a series of orders.  Order books\n    are mutable lists, and mutating them during generation will affect the\n    next turn!\n    \"\"\"\n    for t, stock, side, order, size in orders:\n        if stock_name == stock:\n            new = add_book(book.get(side, []), order, size)\n            book[side] = sorted(new, reverse=side == \"buy\", key=lambda x: x[0])\n        bids, asks = clear_book(**book)\n        yield t, bids, asks\n\n\n################################################################################\n#\n# Test Data Persistence\n\n\ndef generate_csv():\n    \"\"\"Generate a CSV of order history.\"\"\"\n    with open(\"test.csv\", \"wb\") as f:\n        writer = csv.writer(f)\n        for t, stock, side, order, size in orders(market()):\n            if t > MARKET_OPEN + SIM_LENGTH:\n                break\n            writer.writerow([t, stock, side, order, size])\n\n\ndef read_csv():\n    \"\"\"Read a CSV or order history into a list.\"\"\"\n    with open(\"test.csv\", \"rt\") as f:\n        for time, stock, side, order, size in csv.reader(f):\n            yield dateutil.parser.parse(time), stock, side, float(order), int(size)\n\n\n################################################################################\n#\n# Server\n\n\nclass ThreadedHTTPServer(ThreadingMixIn, http.server.HTTPServer):\n    \"\"\"Boilerplate class for a multithreaded HTTP Server, with working\n    shutdown.\n    \"\"\"\n\n    allow_reuse_address = True\n\n    def shutdown(self):\n        \"\"\"Override MRO to shutdown properly.\"\"\"\n        self.socket.close()\n        http.server.HTTPServer.shutdown(self)\n\n\ndef route(path):\n    \"\"\"Decorator for a simple bottle-like web framework.  Routes path to the\n    decorated method, with the rest of the path as an argument.\n    \"\"\"\n\n    def _route(f):\n        setattr(f, \"__route__\", path)\n        return f\n\n    return _route\n\n\ndef read_params(path):\n    \"\"\"Read query parameters into a dictionary if they are parseable,\n    otherwise returns None.\n    \"\"\"\n    query = path.split(\"?\")\n    if len(query) > 1:\n        query = query[1].split(\"&\")\n        return dict(map(lambda x: x.split(\"=\"), query))\n\n\ndef get(req_handler, routes):\n    \"\"\"Map a request to the appropriate route of a routes instance.\"\"\"\n    for name, handler in routes.__class__.__dict__.items():\n        if hasattr(handler, \"__route__\"):\n            if None != re.search(handler.__route__, req_handler.path):\n                req_handler.send_response(200)\n                req_handler.send_header(\"Content-Type\", \"application/json\")\n                req_handler.send_header(\"Access-Control-Allow-Origin\", \"*\")\n                req_handler.end_headers()\n                params = read_params(req_handler.path)\n                data = json.dumps(handler(routes, params)) + \"\\n\"\n                req_handler.wfile.write(bytes(data, encoding=\"utf-8\"))\n                return\n\n\ndef run(routes, host=\"0.0.0.0\", port=8080):\n    \"\"\"Runs a class as a server whose methods have been decorated with\n    @route.\n    \"\"\"\n\n    class RequestHandler(http.server.BaseHTTPRequestHandler):\n        def log_message(self, *args, **kwargs):\n            pass\n\n        def do_GET(self):\n            get(self, routes)\n\n    server = ThreadedHTTPServer((host, port), RequestHandler)\n    thread = threading.Thread(target=server.serve_forever)\n    thread.daemon = True\n    thread.start()\n    print(\"HTTP server started on port 8080\")\n    while True:\n        from time import sleep\n\n        sleep(1)\n    server.shutdown()\n    server.start()\n    server.waitForThread()\n\n\n################################################################################\n#\n# App\n\nops = {\n    \"buy\": operator.le,\n    \"sell\": operator.ge,\n}\n\n\nclass App(object):\n    \"\"\"The trading game server application.\"\"\"\n\n    def __init__(self):\n        self._book_1 = dict()\n        self._book_2 = dict()\n        self._data_1 = order_book(read_csv(), self._book_1, \"ABC\")\n        self._data_2 = order_book(read_csv(), self._book_2, \"DEF\")\n        self._rt_start = datetime.now()\n        self._sim_start, _, _ = next(self._data_1)\n        self.read_10_first_lines()\n\n    @property\n    def _current_book_1(self):\n        for t, bids, asks in self._data_1:\n            if REALTIME:\n                while t > self._sim_start + (datetime.now() - self._rt_start):\n                    yield t, bids, asks\n            else:\n                yield t, bids, asks\n\n    @property\n    def _current_book_2(self):\n        for t, bids, asks in self._data_2:\n            if REALTIME:\n                while t > self._sim_start + (datetime.now() - self._rt_start):\n                    yield t, bids, asks\n            else:\n                yield t, bids, asks\n\n    def read_10_first_lines(self):\n        for _ in iter(range(10)):\n            next(self._data_1)\n            next(self._data_2)\n\n    @route(\"/query\")\n    def handle_query(self, x):\n        \"\"\"Takes no arguments, and yields the current top of the book;  the\n        best bid and ask and their sizes\n        \"\"\"\n        try:\n            t1, bids1, asks1 = next(self._current_book_1)\n            t2, bids2, asks2 = next(self._current_book_2)\n        except Exception as e:\n            print(\"error getting stocks...reinitalizing app\")\n            self.__init__()\n            t1, bids1, asks1 = next(self._current_book_1)\n            t2, bids2, asks2 = next(self._current_book_2)\n        t = t1 if t1 > t2 else t2\n        print(\"Query received @ t%s\" % t)\n        return [\n            {\n                \"id\": x and x.get(\"id\", None),\n                \"stock\": \"ABC\",\n                \"timestamp\": str(t),\n                \"top_bid\": bids1 and {\"price\": bids1[0][0], \"size\": bids1[0][1]},\n                \"top_ask\": asks1 and {\"price\": asks1[0][0], \"size\": asks1[0][1]},\n            },\n            {\n                \"id\": x and x.get(\"id\", None),\n                \"stock\": \"DEF\",\n                \"timestamp\": str(t),\n                \"top_bid\": bids2 and {\"price\": bids2[0][0], \"size\": bids2[0][1]},\n                \"top_ask\": asks2 and {\"price\": asks2[0][0], \"size\": asks2[0][1]},\n            },\n        ]\n\n\n################################################################################\n#\n# Main\n\nif __name__ == \"__main__\":\n    if not os.path.isfile(\"test.csv\"):\n        print(\"No data found, generating...\")\n        generate_csv()\n    run(App())\n"
        }
    ]
}